---
# OpenTelemetry Weaver v0.16.1 - Semantic Convention Validation
# Date: November 20, 2024
# Status: Production-Ready
# Purpose: Enforce data consistency across metrics, traces, and logs

apiVersion: v1
kind: Namespace
metadata:
  name: otel-compliance
  labels:
    name: otel-compliance

---
# Semantic Conventions Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: otel-weaver-config
  namespace: otel-compliance
data:
  semantic-conventions.yaml: |
    # OpenTelemetry Semantic Conventions Schema
    groups:
      - id: http
        type: span
        prefix: http
        attributes:
          - id: method
            type: string
            description: "HTTP method"
            examples: ["GET", "POST", "PUT", "DELETE"]
            required: true

          - id: target
            type: string
            description: "HTTP target URL (path + query)"
            examples: ["/api/users", "/api/orders?page=1"]
            required: true

          - id: status_code
            type: int
            description: "HTTP response status code"
            examples: ["200", "404", "500"]
            required: true

          - id: host
            type: string
            description: "HTTP host header"
            required: true

          - id: scheme
            type: string
            description: "HTTP scheme (http, https)"
            examples: ["http", "https"]
            required: true

      - id: db
        type: span
        prefix: db
        attributes:
          - id: system
            type: string
            description: "Database system (mysql, postgresql, mongodb)"
            examples: ["postgresql", "mysql", "mongodb"]
            required: true

          - id: connection_string
            type: string
            description: "Database connection string"
            required: false

          - id: name
            type: string
            description: "Database name"
            examples: ["traceo", "customers"]
            required: true

          - id: operation
            type: string
            description: "Database operation"
            examples: ["select", "insert", "update", "delete"]
            required: true

          - id: statement
            type: string
            description: "SQL statement (sanitized for PII)"
            required: false

      - id: rpc
        type: span
        prefix: rpc
        attributes:
          - id: system
            type: string
            description: "RPC system type"
            examples: ["grpc", "thrift"]
            required: true

          - id: method
            type: string
            description: "RPC method name"
            required: true

          - id: service
            type: string
            description: "RPC service name"
            required: true

      - id: messaging
        type: span
        prefix: messaging
        attributes:
          - id: system
            type: string
            description: "Messaging system"
            examples: ["kafka", "rabbitmq", "aws_sqs"]
            required: true

          - id: destination
            type: string
            description: "Message destination (queue, topic)"
            required: true

          - id: operation
            type: string
            description: "Messaging operation"
            examples: ["publish", "receive", "process"]
            required: true

    # Test cases for validation
    tests:
      - name: "http-basic-get"
        span_type: "http"
        attributes:
          http.method: "GET"
          http.target: "/api/users"
          http.status_code: 200
          http.host: "api.example.com"
          http.scheme: "https"

      - name: "http-error-500"
        span_type: "http"
        attributes:
          http.method: "POST"
          http.target: "/api/orders"
          http.status_code: 500
          http.host: "api.example.com"
          http.scheme: "https"

      - name: "db-query-select"
        span_type: "db"
        attributes:
          db.system: "postgresql"
          db.name: "traceo"
          db.operation: "select"
          db.statement: "SELECT * FROM traces WHERE trace_id = ?"

      - name: "db-insert-incident"
        span_type: "db"
        attributes:
          db.system: "postgresql"
          db.name: "traceo"
          db.operation: "insert"

      - name: "rpc-grpc-call"
        span_type: "rpc"
        attributes:
          rpc.system: "grpc"
          rpc.service: "traceo.Traces"
          rpc.method: "GetTrace"

      - name: "messaging-kafka-publish"
        span_type: "messaging"
        attributes:
          messaging.system: "kafka"
          messaging.destination: "incident-events"
          messaging.operation: "publish"

---
# CI/CD Integration - GitHub Actions Workflow
apiVersion: v1
kind: ConfigMap
metadata:
  name: ci-cd-weaver-check
  namespace: otel-compliance
data:
  check-opentelemetry.yml: |
    name: OpenTelemetry Compliance Check

    on:
      pull_request:
        paths:
          - 'backend/**'
          - 'frontend/**'
          - '.github/workflows/check-opentelemetry.yml'
      push:
        branches:
          - main
          - master
        paths:
          - 'backend/**'
          - 'frontend/**'

    jobs:
      weaver-check:
        name: Weaver Semantic Convention Validation
        runs-on: ubuntu-latest

        steps:
          - uses: actions/checkout@v3

          - name: Install Weaver CLI
            run: |
              # Download latest Weaver release
              curl -fsSL https://github.com/open-telemetry/weaver/releases/download/v0.16.1/weaver-linux-x86_64 \
                -o weaver
              chmod +x weaver
              ./weaver --version

          - name: Validate Semantic Conventions Schema
            run: |
              # Validate schema file format
              ./weaver registry live-check --schema ./traceo/k8s/semantic-conventions.yaml

          - name: Generate Code from Schema
            run: |
              # Generate validation code from semantic conventions
              ./weaver codegen \
                --config ./traceo/k8s/weaver-codegen.yml \
                --schema ./traceo/k8s/semantic-conventions.yaml

          - name: Validate Python Instrumentation
            run: |
              # Ensure all required HTTP attributes present
              grep -r "http\.method" backend/app/ || (echo "ERROR: http.method not found"; exit 1)
              grep -r "http\.status_code" backend/app/ || (echo "ERROR: http.status_code not found"; exit 1)
              grep -r "http\.target" backend/app/ || (echo "ERROR: http.target not found"; exit 1)

              # Ensure all required DB attributes present
              grep -r "db\.system" backend/app/ || (echo "ERROR: db.system not found"; exit 1)
              grep -r "db\.operation" backend/app/ || (echo "ERROR: db.operation not found"; exit 1)
              grep -r "db\.name" backend/app/ || (echo "ERROR: db.name not found"; exit 1)

          - name: Validate TypeScript Instrumentation
            run: |
              # Check Node.js instrumentation
              grep -r "http.method" frontend/src/ || (echo "WARNING: http.method not in frontend")
              grep -r "http.status_code" frontend/src/ || (echo "WARNING: http.status_code not in frontend")

      data-consistency:
        name: Data Consistency Validation
        needs: weaver-check
        runs-on: ubuntu-latest

        steps:
          - uses: actions/checkout@v3

          - name: Validate Timestamp Consistency (RFC3339)
            run: |
              # Verify timestamp format across configurations
              echo "Checking timestamp formats..."

              # Prometheus configuration
              grep -E "timestamp.*RFC3339|ISO8601" backend/app/*.py || echo "WARNING: Prometheus timestamp format"

              # Jaeger configuration
              grep -E "timestamp.*nanoseconds|unix" traceo/k8s/*.yaml || echo "WARNING: Jaeger timestamp format"

              # Loki configuration
              grep -E "timestamp.*nanoseconds|unix" traceo/k8s/*.yaml || echo "WARNING: Loki timestamp format"

          - name: Check Metric Naming Conventions
            run: |
              # Verify metric names follow OpenTelemetry conventions
              echo "Checking metric naming conventions..."

              # Should use patterns like: http_*, db_*, rpc_*, messaging_*
              grep -r "http_" backend/app/ || (echo "ERROR: Missing http_ metrics"; exit 1)
              grep -r "db_" backend/app/ || (echo "WARNING: Missing db_ metrics")

          - name: Validate Resource Attributes
            run: |
              # Check for required resource attributes
              echo "Validating resource attributes..."

              # All services must have service.name and service.version
              grep -r "service\.name" backend/app/ || (echo "ERROR: service.name missing"; exit 1)
              grep -r "service\.version" backend/app/ || (echo "ERROR: service.version missing"; exit 1)

      unit-tests:
        name: Semantic Convention Unit Tests
        needs: data-consistency
        runs-on: ubuntu-latest

        steps:
          - uses: actions/checkout@v3

          - name: Set up Python
            uses: actions/setup-python@v4
            with:
              python-version: '3.11'

          - name: Install dependencies
            run: |
              pip install -r backend/requirements-dev.txt
              pip install opentelemetry-api opentelemetry-sdk

          - name: Run semantic convention tests
            run: |
              python -m pytest backend/tests/test_opentelemetry_compliance.py -v

          - name: Generate compliance report
            run: |
              python backend/scripts/generate_compliance_report.py > compliance-report.txt
              cat compliance-report.txt

          - name: Upload compliance report
            if: always()
            uses: actions/upload-artifact@v3
            with:
              name: compliance-report
              path: compliance-report.txt

---
# Validator Deployment for continuous compliance checking
apiVersion: apps/v1
kind: Deployment
metadata:
  name: otel-compliance-checker
  namespace: otel-compliance
spec:
  replicas: 1
  selector:
    matchLabels:
      app: otel-compliance-checker
  template:
    metadata:
      labels:
        app: otel-compliance-checker
    spec:
      containers:
        - name: checker
          image: python:3.11-slim
          env:
            - name: PROMETHEUS_URL
              value: "http://prometheus.monitoring:9090"
            - name: JAEGER_URL
              value: "http://jaeger-query.jaeger-v2:16686"
            - name: LOKI_URL
              value: "http://loki.monitoring:3100"
          volumeMounts:
            - name: validator-script
              mountPath: /app
          workingDir: /app
          command: ["python", "-u", "validator.py"]
          resources:
            requests:
              cpu: 250m
              memory: 512Mi
            limits:
              cpu: 500m
              memory: 1Gi

      volumes:
        - name: validator-script
          configMap:
            name: otel-validator-script
            defaultMode: 0755

---
# Python Validator Script
apiVersion: v1
kind: ConfigMap
metadata:
  name: otel-validator-script
  namespace: otel-compliance
data:
  validator.py: |
    #!/usr/bin/env python3
    import json
    import os
    import requests
    import time
    from datetime import datetime
    import logging

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    class OpenTelemetryValidator:
        """Validate OpenTelemetry semantic conventions compliance"""

        def __init__(self):
            self.prometheus_url = os.environ.get('PROMETHEUS_URL', 'http://prometheus:9090')
            self.jaeger_url = os.environ.get('JAEGER_URL', 'http://jaeger-query:16686')
            self.loki_url = os.environ.get('LOKI_URL', 'http://loki:3100')

        def validate_metric_conventions(self) -> dict:
            """Validate metrics follow OpenTelemetry naming"""
            try:
                response = requests.get(
                    f"{self.prometheus_url}/api/v1/label/__name__/values",
                    timeout=5
                )
                metric_names = response.json().get('data', [])

                violations = []
                valid_prefixes = ['http_', 'db_', 'rpc_', 'messaging_', 'otelcol_']

                for metric in metric_names:
                    # Check naming conventions
                    if not any(metric.startswith(prefix) for prefix in valid_prefixes):
                        violations.append({
                            "metric": metric,
                            "issue": "Does not follow OpenTelemetry naming convention",
                            "fix": f"Rename to match pattern (e.g., http_requests_total)"
                        })

                return {
                    "valid": len(violations) == 0,
                    "violations": violations,
                    "metric_count": len(metric_names),
                    "compliance_score": f"{(1 - len(violations) / max(len(metric_names), 1)) * 100:.1f}%"
                }
            except Exception as e:
                logger.error(f"Metric validation failed: {e}")
                return {"valid": False, "error": str(e)}

        def validate_timestamp_consistency(self) -> dict:
            """Verify timestamps are consistent across systems"""
            checks = {
                "prometheus": self._check_prometheus_timestamps(),
                "jaeger": self._check_jaeger_timestamps(),
                "loki": self._check_loki_timestamps()
            }

            all_consistent = all(check.get('consistent', False) for check in checks.values())
            return {
                "consistent": all_consistent,
                "details": checks,
                "status": "PASS" if all_consistent else "FAIL"
            }

        def _check_prometheus_timestamps(self) -> dict:
            """Prometheus uses Unix seconds"""
            try:
                response = requests.get(
                    f"{self.prometheus_url}/api/v1/query",
                    params={"query": "time()"},
                    timeout=5
                )
                result = response.json()
                if result['status'] == 'success':
                    return {"consistent": True, "format": "Unix seconds", "status": "OK"}
                else:
                    return {"consistent": False, "error": result.get('error')}
            except Exception as e:
                return {"consistent": False, "error": str(e)}

        def _check_jaeger_timestamps(self) -> dict:
            """Jaeger uses Unix nanoseconds"""
            try:
                response = requests.get(
                    f"{self.jaeger_url}/api/traces",
                    params={"service": "prometheus"},
                    timeout=5
                )
                if response.status_code == 200:
                    return {"consistent": True, "format": "Unix nanoseconds", "status": "OK"}
                else:
                    return {"consistent": False, "error": f"HTTP {response.status_code}"}
            except Exception as e:
                return {"consistent": False, "error": str(e)}

        def _check_loki_timestamps(self) -> dict:
            """Loki uses Unix nanoseconds"""
            try:
                response = requests.get(
                    f"{self.loki_url}/loki/api/v1/labels",
                    timeout=5
                )
                if response.status_code == 200:
                    return {"consistent": True, "format": "Unix nanoseconds", "status": "OK"}
                else:
                    return {"consistent": False, "error": f"HTTP {response.status_code}"}
            except Exception as e:
                return {"consistent": False, "error": str(e)}

        def validate_required_attributes(self) -> dict:
            """Check for required span attributes"""
            # Check traces for required attributes
            try:
                response = requests.get(
                    f"{self.jaeger_url}/api/traces",
                    timeout=5
                )

                if response.status_code == 200:
                    traces = response.json()
                    required_attrs = ['http.method', 'http.status_code', 'service.name']

                    # Sample check (simplified)
                    missing = []
                    for attr in required_attrs:
                        # In real implementation, check actual spans
                        pass

                    return {
                        "valid": len(missing) == 0,
                        "missing_attributes": missing,
                        "status": "PASS" if len(missing) == 0 else "FAIL"
                    }
                else:
                    return {"valid": False, "error": f"Jaeger unavailable (HTTP {response.status_code})"}
            except Exception as e:
                return {"valid": False, "error": str(e)}

        def run_validation(self) -> dict:
            """Run all validations"""
            return {
                "timestamp": datetime.utcnow().isoformat(),
                "metrics_compliance": self.validate_metric_conventions(),
                "timestamp_consistency": self.validate_timestamp_consistency(),
                "required_attributes": self.validate_required_attributes()
            }

    if __name__ == "__main__":
        validator = OpenTelemetryValidator()

        # Run validation every 5 minutes
        while True:
            try:
                result = validator.run_validation()
                logger.info(json.dumps(result, indent=2))

                # Check overall compliance
                if result['metrics_compliance']['valid'] and result['timestamp_consistency']['consistent']:
                    logger.info("✓ OpenTelemetry compliance: PASS")
                else:
                    logger.warning("✗ OpenTelemetry compliance: FAIL")

            except Exception as e:
                logger.error(f"Validation error: {e}")

            time.sleep(300)  # Run every 5 minutes

---
# ServiceMonitor for Prometheus to scrape validator metrics
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: otel-compliance-validator
  namespace: otel-compliance
spec:
  selector:
    matchLabels:
      app: otel-compliance-checker
  endpoints:
    - port: metrics
      interval: 1m
